# 摸鱼精选第 32 期

## 1. [2023 春夏季开源操作系统训练营](https://learningos.github.io/rust-based-os-comp2023/)

本教程展示了如何 从零开始 用 Rust 语言写一个基于 RISC-V 架构的 类 Unix 内核 。

## 2. [PromptPerfect](https://promptperfect.jinaai.cn/)

本网站针对 GPT 的 Promt 进行优化。大部分人能够说话，但不懂聊天，俗称口才不行。感觉在 GPT 领域也是一样，同一件事，不同的 Promt 得出的答案有很大区别。

## 3. [Uber Go 语言编码规范](https://github.com/uber-go/guide/blob/master/style.md)

本指南的目的是通过详细描述在 Uber 编写 Go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用 Go 语言功能。

中文翻译：[xxjwxc/uber_go_guide_cn](github.com/xxjwxc/uber_go_guide_cn)

## 4. [成为搞懂 GPT 的少数人](https://docs.qq.com/aio/DWVZ2ZXZ0RW9xb2Z4?p=XeFtQCxmgqB3SpZeKodGpg)

## 5. [Is Parallel Programming Hard, And, If So, What Can You Do About It?](https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html)

本书是 Linux 内核大牛 paul 的力作， 主要讲解并行编程的内容。

最新的英文版是 v2023.06.11a。

有一个很老的中文翻译版本：[《深入理解并行编程》](http://ifeve.com/perfbook/?continueFlag=09b6189ec215768da9c6480e8ff78bfe)

## 6. [chinese-poetry: 最全中文诗歌古典文集数据库](https://github.com/chinese-poetry/chinese-poetry)

> 最全的中华古典文集数据库，包含 5.5 万首唐诗、26 万首宋诗、2.1 万首宋词和其他古典文集。诗人包括唐宋两朝近 1.4 万古诗人，和两宋时期 1.5 千古词人。数据来源于互联网。

## 7. [Codeium for Xcode](https://github.com/intitni/CodeiumForXcode)

Xcode 最让开发者诟病的可能就是开放性了，插件 API 能做的事情太少，只能针对 Editor 部分加砖添瓦。但还是有很多人在 Xcode 上面不懈努力，尤其是 Copilot 出来之后，iOS/Mac 开发者对 VS Code 简直是羡慕嫉妒恨，所以 [Copilot for Xcode](https://github.com/intitni/CopilotForXcode) 出来了。但是 Copilot 或者 chatGPT 都要收费，所以目前我的 VS Code 使用的是 [Codeium](https://codeium.com/)，一个免费的 AI 代码助手。

## 8. [Building a design system with Tailwind CSS: A step-by-step guide](https://uxplanet.org/building-a-design-system-with-tailwind-css-a-step-by-step-guide-f03f99f87aba)

学习如何在 Figma 中创建一个设计系统，并逐步练习，包括创建 Figma 样式和变量，以实现一致和高效的设计工作流程。

## 9. [尼尔森十大交互原则](https://www.zcool.com.cn/article/ZMTA2ODAwNA==.html?)

尼尔森的十大可用性原则被广泛运用于网页、APP 以及各种人机交互领域。

## 10. [Node.js Best Practices](https://github.com/goldbergyoni/nodebestpractices)

Node.js 最佳实践。

有中文翻译: [goldbergyoni/nodebestpractices](https://github.com/goldbergyoni/nodebestpractices/blob/master/README.chinese.md)

## 11. [Riverpod 学习笔记](https://juejin.cn/post/7236286358388768826)

- [Riverpod 之 Provider(一)](https://juejin.cn/post/7236286358388768826)，使用 Provider 讲解了 WidgetRef 和 Ref 的 watch 要点

- [Riverpod 之 StateProvider（二）](https://juejin.cn/post/7236634485290139705),讲解了 StateProvider 的内部流程，主要涉及的是其内部的名叫 state 的 Provider。

- [Riverpod 之 Provider&StateProvider(三)](https://juejin.cn/post/7240374267695218746),讲解了 Provider 和 StateProvider 的组合使用。

- [Riverpod 之 StateNotifierProvider（四）](https://juejin.cn/post/7250248744872312889),介绍了 StateNotifierProvider 的使用。

- [Riverpod 之 FutureProvider（五）](https://juejin.cn/post/7251501786124861499),介绍了 FutureProvider 的使用。

- [Riverpod 之 select（六）](https://juejin.cn/post/7251863105080213560),介绍了 Provider 的 select 方法使用和原理。

- [Riverpod 之 family（七）](https://juejin.cn/post/7254391275801215037)，介绍了 family 方法得使用和内部流程

- [Riverpod 之 autoDispose(八)](https://juejin.cn/post/7257039072362184763)，介绍了 autoDispose 方法的使用和内部流程

- [Riverpod 之 override（九）](https://juejin.cn/post/7267418854123978806)，介绍了 override 属性的使用和内部流程

## 12. [RocksDB 源码学习](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkyMjIxMzIxNA==&action=getalbum&album_id=2080658623390613505&scene=173&from_msgid=2247488051&from_itemidx=1&count=3&nolastread=1#wechat_redirect)

## 13. [Bad practice: capturing a method reference](https://www.swiftwithvincent.com/blog/bad-practice-capturing-a-method-reference)

在使用 Swift 的 Combine 时，注意订阅事件时的`sink(receiveValue:)`方法如果传递是实例方法 `handle(value:)`，会默认 capture self。

```swift
class ViewModel {

    var cancellables = Set<AnyCancellable>()

    init() {
        publisher
            .sink(receiveValue: handle(value:))
            .store(in: &cancellables)
    }

    func handle(value: String) {
        // `self` can be used here
    }
}
```

这里相当于:

```swift
class ViewModel {
  ...
  init() {
        publisher
            .sink(receiveValue: {
              self.handle(value: $0)
            })
            .store(in: &cancellables)
  }
  ...
}
```

## 14. [深入理解 Observation - 原理，back porting 和性能](https://onevcat.com/2023/08/observation-framework/)

在 WWDC 23 中，Apple 推出了全新的 Observation 框架，旨在解决 SwiftUI 上的状态管理混乱和性能问题。这个框架的工作方式看似非常神奇，甚至无需特别声明，就能在 View 中实现属性粒度的订阅，从而避免不必要的刷新。本篇文章将深入探讨背后的原理，帮助您：

- 理解 Observation 框架的实质和实现机制
- 比较其与之前解决方案的优势所在
- 介绍一种把 Observation 前向兼容到 iOS 14 的方式
- 探讨在处理 SwiftUI 状态管理时的一些权衡与考虑

## 15. [领悟到 NSCoding 是一个坑，Apple 花了 10 年时间](https://github.com/ChenYilong/iOS12AdaptationTips/issues/1)

本文主要阐述以下观点，如果你早已知晓，请忽略本条内容：

- Apple 在 2008 年 7 月 11 日 推出的 iOS2 里，带来了 NSKeyedArchiver、NSKeyedUnarchiver，2018 年 9 月 10 日发布的 iOS12 几乎废弃了 NSKeyedArchiver、NSKeyedUnarchiver 中所有的方法，甚至包括 init 方法。Apple 花了 10 年时间，发现 NSCoding 是一个坑。
- iOS6 推出的 NSSecureCoding 是高配版本的 NSCoding，NSCoding 并不适合你用，请及早弃坑。而这不是你的问题，是 NSCoder、NSKeyedArchiver、NSKeyedUnarchiver 内部实现有问题。iOS6 修复了 NSCoder 的问题，iOS12 修复的是 NSKeyedArchiver、NSKeyedUnarchiver。
- UIKit 出厂时还在用 NSCoding，Foundation 出厂时，标配 NSSecureCoding。
- Foundation 中任何类都可以遵循 NSCoding，但是 NSObject 出厂时，并没有遵循。所以实现 `-initWithCoder:` 时，不能总是调用父类的 `[super initWithCoder:]`，有时要调 `[super init]`。
- Nib 与 Storyboard 方式加载的 UIViewController ，是通过 `-initWithNibName:bundle:` 来声明文件路径，`-initWithCoder:` 与 NSKeyedUnarchiver 来加载的。了解这一点，有助于理解 UIViewController 生命周期。
- 当一个对象被初始化时，init 方法可能并不会被执行，可能是通过执行 `-initWithCoder:` 初始化，所以只在 init 进行初始化，可能会丢失数据、属性。 `-initWithCoder:` 常常被忽略。

## 16. [iOS 限制输入表情(emoji)，出现九宫格不能输入的解决方法](https://www.jianshu.com/p/d0f6c62b57e1)

九宫格预览时，会用 ➋➌➍➎➏➐➑➒ 替代 A-Z 的位置，当用户在预览选择了具体的词汇之后，textField 的 text 才会回调真实的文本。

## 17. [Swift 结构化并发进阶](https://mp.weixin.qq.com/s/VzUl8RM4t7CwIccjhAKxBg)

本文章基于 WWDC23 中 [Beyond the basics of structured concurrency](https://developer.apple.com/videos/play/wwdc2023/10170/) 进行创作：

- 结构化任务在任务取消上相较于非结构化任务的优势
- 结构化任务在任务优先级传递上的优势
- 结构化任务结合 TaskLocal 包裹值在单个任务中复用任务维度属性的优势
- 结构化任务在全链路性能追踪中的优势

## 18. [美团前端研发框架 Rome 实践和演进趋势](https://mp.weixin.qq.com/s/zywrCSSHnYMu6Uh54MHN0Q)

本文整理自美团技术沙龙第 76 期《大前端研发协同效能提升与实践》，为大家介绍了美团到店前端研发框架 Rome 实践和演进趋势。

具体来讲，本文首先介绍了 Rome 整体的工程生态、演变路径、规模化升级以及工程框架外的开发辅助工具；第二部分，重点阐述了如何做框架度量和相关的业务实践；最后做整体的总结以及对工程框架的下一阶段的思考。希望能对大家带来一些帮助或启发。

## 19. [一文揭秘饿了么跨端技术的演进、实践与落地](https://mp.weixin.qq.com/s/h8HDtYLj0skRsPSkmEtShg)

本文会先带领大家一起简单回顾下跨端技术背景与演进历程与在这一波儿接着一波儿的跨端浪潮中的饿了么跨端现状，以及在这个背景下，相较于业界基于 React/Vue 研发习惯出发的各种跨端方案，饿了么为什么会选择走另外一条路，这个过程中我们的一些思考、遇到及解决的问题和取得的一些成果，希望能给大家带来一些跨端方面的新思路。

## 20. [Redis Sorted Set 底层实现原理深度解读与排行榜实战](https://mp.weixin.qq.com/s/N1fGWIB-UR_gqP__KXIISg)

本文主要探讨了 Redis Sorted Set 数据类型底层的实现原理和游戏排行榜实战。

## 21. [Flutter 的线程模型和异步原理](https://mp.weixin.qq.com/s/XvVD-yG79x8KX1U5LJgMvg)

对 Flutter 中的线程模型和单线程异步原理有了更深入的理解，开发时也能更好更安全地运用 Flutter 的 Isolate，Future 和 await。

总结下文章的核心内容：

- `Isolate`是`Dart`平台对线程的实现方案。和普通`Thread`不同，`Isolate `拥有独立的内存，由线程和独立内存构成。`Isolate`线程之间并不存在资源抢夺的问题，所以也不需要线程同步机制；
- 简单耗时任务，可以使用简版`Isolate`：`compute`；
- `Isolate`通过事件循环和消息队列来实现单线程异步并发，这比多线程异步并发要轻便；
- 可以通过`Future`进行单线程异步并。`Future`异步的特点是提供了链式调用，可以解决回调地狱，异常捕获和代码执行依赖等问题；
- 也可以通过`async`和`await`实现单线程异步并发，它是同步风格的异步操作，比`Future`更简洁美观；
- `Root Isolate`支持`IO`耗时操作，但不支持高`CPU`耗时操作。

## 22. [干货 | 携程商旅大前端 React Streaming 的探索之路](https://mp.weixin.qq.com/s/HUJTU5Du6318LJ7RfQNN2g)

本文主要介绍 React 18 中的 Streaming。

## 23. [Jenkins 真得很牛！只是大部分人不会用而已~(保姆级教程)](https://mp.weixin.qq.com/s/w6q7drmnRsJdVUWMHjU1lA)

jenkins 有 2 种流水线分为声明式流水线与脚本化流水线，脚本化流水线是 jenkins 旧版本使用的流水线脚本，新版本 Jenkins 推荐使用声明式流水线。文档只介绍声明流水线。

## 24. [百度 iOS 端长连接组件建设及应用实践](https://mp.weixin.qq.com/s/5QvP30J0R4r3_uGHhfAxFA)

本文旨在探讨长连接技术在移动端的实践，针对百度 iOS 端在建设长连接过程中的技术选型和整体架构逻辑将做重点展开。同时结合 IM 即时通讯案例的介绍和分析，展示长连接是如何在移动应用领域为类似业务场景提供解决方案的。

本文将分为五个主要部分。首先，对长连接技术进行概述，包括定义、与短连接的对比以及在移动互联网领域的常见应用。接下来，会简单介绍百度长连接服务，包括搭建的背景以及建成后提供的服务核心主流程。然后，将重点讨论百度 iOS 端长连接 SDK 搭建过程中的挑战和解决方案，包含协议的选择、DNS 解析优化、长连接保活机制的设计等。紧接着，以 IM 即时通讯场景中的长连接实践为例，展示了长连接 SDK 是如何为业务实现请求数据转发、接收服务器主动推送等功能的。最后，对本文的主要内容做了总结，以及对长连接在移动端应用中未来的发展趋势和前景进行了展望。

## 25. [深入解析 Redis 的 LRU 与 LFU 算法实现](https://mp.weixin.qq.com/s/LsxzvpegWk6XVqhuqHKS4g)

重点介绍了 Redis 的 LRU 与 LFU 算法实现，并分析总结了两种算法的实现效果以及存在的问题。

Redis 4.0 版本开始就提供了 8 种内存淘汰策略，其中 4 种都是基于 LRU 或 LFU 算法实现的，本文就这两种算法的 Redis 实现进行了详细的介绍，并阐述其优劣特性。

通过对 Redis LRU 与 LFU 算法实现的介绍，我们可以大体了解两种算法策略的优缺点，在 Redis 运维过程中，可以依据业务数据的特性去选择相应的算法。

如果业务数据的访问较为均匀，OPS 或 CPU 利用率一般不会出现周期性的陡升或陡降，数据没有体现出相对的“冷热”特性，即建议采用 LRU 算法，可以满足一般的运维需求。

相反，业务具备很强时效性，在活动推广或大促期间，业务某些数据会突然成为热点数据，监控上呈现出 OPS 或 CPU 利用率的大幅波动，为了能抓取热点数据便于后期的分析或优化，建议一定要配置成 LFU 算法。

在 Used_memory 接近 Maxmemory 的情况下，Redis 一直都采用随机的方式筛选数据，且筛选的个数极其有限，所以，LFU 算法无法展现出较大的优势，也可能会淘汰掉比较热的数据。

## 26. [ReactNative 状态管理](https://mp.weixin.qq.com/s/bqLMt0qPFVzoY_kUWmXMIg)

本文来自快手电商无线团队，主要介绍了 ReactNative 里常见的状态管理方式，包括 RN 官方提供的方案与其他第三方框架的对比，同时也给出了 Redux ToolKit 和 Zustand 的最佳实践。

## 27. [百度 APP iOS 端包体积 50M 优化实践(三) 资源优化](https://mp.weixin.qq.com/s/lLTheHc4T_ADn-j-Uof2KA)

百度 APP iOS 端包体积优化系列文章的前两篇重点介绍了包体积优化整体方案、各项优化收益和图片优化方案，图片优化是从无用图片、Asset Catalog 和 HEIC 格式三个角度做深度优化。本文重点介绍资源优化，在百度 APP 实践中，资源优化包括大资源优化、无用配置文件和重复资源优化。不管是资源优化还是代码优化，都需要分析 Mach-O 文件，以获取资源和代码的引用关系，本文先详细介绍 Mach-O 文件。

百度 APP iOS 端包体积优化实践系列文章回顾：

- [《百度 APP iOS 端包体积 50M 优化实践(一)总览》](https://mp.weixin.qq.com/s/DSwjQWgeep2INjCNUE4i4A)
- [《百度 APP iOS 端包体积 50M 优化实践(二) 图片优化》](https://mp.weixin.qq.com/s/K31j3Bc_5vMbDFzBBv3xTA)
